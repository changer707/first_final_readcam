#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <fstream>
#include <random>
#include <chrono>
#include <initializer_list>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <typeinfo>
#include <iterator>
#include "cmath"


#include "header.h"
#include <matrix.h>
#include <munkres.h>
#include "utils.h"
#include "dection.h"
#include "mybox.h"
#include "getline.h"
#include "distance.h"
#include "judge.h"
#include <tracker.h>
#include <kalman_filter.h>
#include "darknet.h"
#include "dec_match.h"
#include "defthreshold.h"

#include <improcess.h>

#include "mulplayer.h"
#include <QApplication>
#include <QSqlQuery>
#include <QDateTime>
#include "ui_mulplayer.h"
#include "connection.h"

//#define self 1//display or not  class



#define judge 1//draw bbox

using namespace std;

/*int main11(MulPlayer*p){
    //std::string path="/home/ps/zk/darknet-master-1";
    //cv::VideoCapture capture(path+"/car-bicycle.mp4");//读取视频，请自行修改相应路径777777777777777777777777
    cv::VideoCapture capture(1);
    cv::VideoCapture capture1(2);
    int frame_count=1;
    cv::Mat frame;
    cv::Mat frame2;
    while(1){


        if (!capture.read(frame)){//read one frame photo
            printf("fail to read.\n");
            return 0;
        }
        ++frame_count;
        cv::imshow("Original", frame);
        cv::imshow("Original", frame2);
        p->video_opencv(frame,1);
        p->video_opencv(frame2,2);
        cv::waitKey(1);

    }
    return 0;

}*/


/*
int main11(MulPlayer*p)
{

    cv::Mat frame;
    cv::Mat frame2;

    cv::VideoCapture cap1(0);
    cv::VideoCapture cap2(1);

    bool stop(false);

    cv::namedWindow("cam1", CV_WINDOW_AUTOSIZE);
    cv::namedWindow("cam2", CV_WINDOW_AUTOSIZE);


    if (cap1.isOpened() && cap2.isOpened())
    {
        cout << "*** ***" << endl;
        cout << "摄像头已启动！" << endl;
    }
    else
    {
        cout << "*** ***" << endl;
        cout << "警告：请检查摄像头是否安装好!" << endl;
        cout << "程序结束！" << endl << "*** ***" << endl;
        return -1;
    }


    cap1.set(CV_CAP_PROP_FOCUS, 0);
    cap2.set(CV_CAP_PROP_FOCUS, 0);


    while (!stop)
    {
        if (cap1.read(frame) && cap2.read(frame2))
        {
            imshow("cam1", frame);
            //imshow("cam2", frame2);

            p->video_opencv(frame);
            //p->video_opencv(frame2,2);

            imwrite("frame1.bmp", frame);
            //imwrite("frame2.bmp", frame2);

            //彩色帧转灰度
            cvtColor(frame, frame, CV_RGB2GRAY);
            //cvtColor(frame2, frame2, CV_RGB2GRAY);


            if (cv::waitKey(1) == 27)//按ESC键
            {
                stop = true;
                cout << "程序结束！" << endl;
                cout << "*** ***" << endl;
            }
        }
    }
    return 0;
}*/

std::string  dec_and_match(std::string video_path, MulPlayer*p,int num = 0)
{
        float img_width=1920;
        float img_height=1080;
        RXY_threinit(img_width,img_height);
        //main11(p);
        //return 0;

        std::string name=video_path.substr(video_path.find_last_of("/")+1,video_path.find_last_of(".")-video_path.find_last_of("/")-1);
        //example name=01
        std::string folder=video_path.substr(0,video_path.find_last_of("/")+1);


        //end with /
        bool enable_display_flag=true;
        std::vector<cv::Scalar> colors;
        constexpr int num_of_colors = 32;
        std::random_device rd;  //Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
        constexpr int max_random_value = 20;
        std::uniform_int_distribution<> dis(0, max_random_value);
        constexpr int factor = 255 / max_random_value;
        for (int n = 0; n < num_of_colors; ++n) {
                        //Use dis to transform the random unsigned int generated by gen into an int in [0, 7]
                        colors.emplace_back(cv::Scalar(dis(gen) * factor, dis(gen) * factor, dis(gen) * factor));
                    }
        std::string darknet_path="/home/ps/zk/darknet-master-1";
        std::string cfgfile =darknet_path+"/cfg/yolov3.cfg";//读取模型文件，请自行修改相应路径
        std::string weightfile =darknet_path+"/yolov3.weights";

        float thresh=0.5;//参数设置
        float nms=0.35;
        int classes=8;


        network *net=load_network((char*)cfgfile.c_str(),(char*)weightfile.c_str(),0);//加载网络模型
        //network is a struct

        set_batch_network(net, 1);//no return

        //cv::VideoCapture capture(video_path);//读取视频，请自行修改相应路径777777777777777777777777
        cv::VideoCapture capture(0);


        cv::namedWindow("cam1", CV_WINDOW_AUTOSIZE);

        p->printmsg("读取视频成功. . .");
        double fps = capture.get(cv::CAP_PROP_FPS);

        cv::Size size((int)capture.get(cv::CAP_PROP_FRAME_WIDTH), (int)capture.get(cv::CAP_PROP_FRAME_HEIGHT));

        cv::VideoWriter writer_match;
        writer_match.open("match.mp4", CV_FOURCC('M', 'J', 'P', 'G'), fps, size, true);
        cv::VideoWriter writer_dec;
        writer_dec.open("dec.mp4", CV_FOURCC('M', 'J', 'P', 'G'), fps, size, true);




        cv::Mat frame;

        cv::Mat rgbImg;


        int missaccident_count=0;//总计消失对象的事故个数
        int nomissaccident_count=0;//总计未消失对象的事故个数
        int like_count=0;
        int vfilterfimss_count=0;
        int addvfilterfmiss_count=0;
        int fmissaccident_count=0;
        int like1_count=0;
        int stayaccident_count=0;
        int total_vs_count=0;

        std::vector<mybox> bbox_per_frame;
        std::vector<std::vector<mybox>> bbox1;
        std::vector<missingbox>miss_to_accidentboxes;//确认为事故的ID（有消失）
        std::vector<mybox>highaboxes;//高加速度的对象
        std::vector<mybox>nomiss_to_accidentboxes;//确认为事故的ID（无消失）
        std::vector<missingbox>like_accidentboxes;//对于消失的ID，通过前后两帧对比找出的疑似事故对象
        std::vector<mybox>like_accidentboxes1;
        std::vector<missingbox> miss_boxes;
        std::vector<mybox> neighbourboxes;
        std::vector<mybox> neighbourboxes1;
        std::vector<missingbox>fmiss_to_accidentboxes;//经过neighbourcheck后的miss_to_accidentboxes
        std::vector<missingbox> countedlike_boxes;//存放已经统计过的疑似对象
        std::vector<missingbox> vfilter_fmiss;//速度滤波后的fmiss
        std::vector<missingbox> vfilter_for_stay;//速度不小,后续stay筛选
        std::vector<missingbox> stay_to_accidentboxes;//crashone碰撞后静止检测(miss已消失)
        std::vector<mybox> stay_to_accidentboxes1;
        std::vector<mybox> high_accelerationboxes;
        std::vector<missingbox> total_vfilter_stay;//静止检测和速度滤波后的输出事故对象
        std::vector<motionparasbox> motionparasboxes;

        bool flag_ID_missing=true;
        bool onlyone_mtoacci=false;
        float mindistance=0;
        float mindistance1=0;



        std::vector<string> classNamesVec;

        std::ifstream classNamesFile(darknet_path+"/data/coco.names");//标签文件coco有80类


        if (classNamesFile.is_open()){
            string className = "";
            while (getline(classNamesFile, className))
                classNamesVec.push_back(className);
        }



        //std::string output_v=darknet_path+"/v.txt";//export all 'v' and 'a'
        std::string output_v="v_1.txt";

        std::ofstream foutput_v(output_v);

        std::string output_path = folder+name+"match.txt";//有输出trk after match


        std::ofstream output_file(output_path);



               // TODO: check if output folder exist
               if (output_file.is_open()) {
                   std::cout << "Result will be exported to " << output_path << std::endl;
               } else {
                   std::cerr << "Unable to open output file" << std::endl;
                  // return -1;
               }

        int current_ID = 0;

        bool stop=false;//
        int frame_index=1;

        std::map<int, Tracker> tracks;

     //   while(frame_index<capture.get(cv::CAP_PROP_FRAME_COUNT)){
       //std::cout<<capture.get(cv::CAP_PROP_FRAME_COUNT);

        //while(frame_index<capture.get(cv::CAP_PROP_FRAME_COUNT)-5){//9999999999999999999999999999999999999999999999999
        while(p->on_btn_closecam_pressed()){
            p->printmsg("正在处理第"+std::to_string(frame_index)+"帧视频. . .");
            constexpr float dt = 0.03333333333333f;//predit of kalman

                        for (auto &track : tracks) {
                            track.second.Predict(dt);
                        }

            if (!capture.read(frame)){//read one frame photo
                printf("fail to read.\n");
               // return 0;
                std::cout<<"if frame"<<std::endl;
                return output_path;
               // return "\0";
            }



            cv::Mat img_tracking = frame.clone();

            cvtColor(frame, rgbImg, cv::COLOR_BGR2RGB);

            float* srcImg;
            size_t srcSize=rgbImg.rows*rgbImg.cols*3*sizeof(float);

            srcImg=(float*)malloc(srcSize);
            imgConvert(rgbImg,srcImg);//将图像转为yolo形式

            float* resizeImg;

            size_t resizeSize=net->w*net->h*3*sizeof(float);

            resizeImg=(float*)malloc(resizeSize);

            imgResize(srcImg,resizeImg,frame.cols,frame.rows,net->w,net->h);//缩放图像

            network_predict(net,resizeImg);//网络推理

            int nboxes=0;
            int nboxes_2=0;
            int nboxes_3=0;
            int nboxes_4=0;
            detection *dets=get_network_boxes(net,rgbImg.cols,rgbImg.rows,thresh,0.5,0,1,&nboxes);//a struct pull

            if(nms){//nms is yuzhi??????????
                do_nms_obj(dets,nboxes,classes,nms);//no return
            }

            vector<Rect_with_class>one_frame_dec;
            Rect_with_class one_dec;

            for (int i = 0; i < nboxes; i++){//nboxes represent the number of dection
                bool flag=0;
                int className;
                for(int j=1;j<=classes;j++){
                    if(dets[i].prob[j-1]>thresh){
                        if(!flag){
                            flag=1;
                            className=j;

                        }
                    }
                }//
                if(flag){//read all bbox in the same frame
                    int left = (dets[i].bbox.x - dets[i].bbox.w / 2.)*frame.cols;
                    int right = (dets[i].bbox.x + dets[i].bbox.w / 2.)*frame.cols;
                    int top = (dets[i].bbox.y - dets[i].bbox.h / 2.)*frame.rows;
                    int bot = (dets[i].bbox.y + dets[i].bbox.h / 2.)*frame.rows;

                    if (left < 0)
                        left = 0;
                    if (right > frame.cols - 1)
                        right = frame.cols - 1;
                    if (top < 0)
                        top = 0;
                    if (bot > frame.rows - 1)
                        bot = frame.rows - 1;

                    one_dec.init(left, top, fabs(left - right), fabs(top - bot),className);//is it right????????????
                    one_frame_dec.push_back(one_dec);
                }
            }
            //for end one frame end,begin match

            free_detections(dets, nboxes);

           for (auto &trk : tracks) {//draw prediction box and to txt

                if (judge||(trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                    const auto &bbox = trk.second.GetStateAsBbox();
                    cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                    std::string display_str=std::to_string(frame_index);
                    display_str+=std::to_string(trk.first);
                    cv::putText(frame, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 5), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                    cv::rectangle(frame, myRect_to_cv, cv::Scalar(0, 255, 0), 3);
                }
            }


            std::map<int,Rect_with_class > matched;

            std::vector<Rect_with_class> unmatched_det;

            AssociateDetectionsToTrackers(one_frame_dec, tracks, matched, unmatched_det,0.45);
                         //相应的输入变量类型 std::vector<cv::Rect>& detection,std::map<int, Tracker>& tracks,std::map<int, cv::Rect>& matched,std::vector<cv::Rect>& unmatched_det,
                        /*** Update tracks with associated bbox ***/
                        for (const auto &match : matched) {
                            const auto &ID = match.first;
                            tracks[ID].Update(match.second);

                            const auto &bbox = tracks[ID].GetStateAsBbox();//draw trk
                            cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                            //std::string display_str=std::to_string(ID)+" "+std::to_string((int)(CalculateIou(match.second,tracks[ID])*100))+" "+std::to_string(frame_index);
                            std::string display_str=std::to_string(ID)+" "+std::to_string(frame_index);
                            //cv::putText(img_tracking, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 10),cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                          //  cv::rectangle(img_tracking, myRect_to_cv,cv::Scalar(255, 0, 0), 1);//blue

                            Rect_with_class decbbox = match.second;//draw dec
                            //cv::Rect decRect_to_cv(decbbox.block.x,decbbox.block.y,decbbox.block.width,decbbox.block.height);
                          // cv::rectangle(img_tracking, decRect_to_cv,cv::Scalar(0, 255, 0), 1);//green
                        }

                        /*** Create new tracks for unmatched detections ***/
                        for (const auto &det : unmatched_det) {
                            Tracker tracker;
                            tracker.Init(det);
                            // Create new track and generate new ID
                            tracks[current_ID++] = tracker;
                        }

                        /*** Delete lose tracked tracks ***/
                        for (auto it = tracks.begin(); it != tracks.end();) {
                            if (it->second.coast_cycles_ > kMaxCoastCycles) {
                                it = tracks.erase(it);
                            } else {
                                it++;
                            }
                        }

                        //output_file << frame_index<<",";
                        for (auto &trk : tracks) { //tracker to  txt
                            const auto &bbox = trk.second.GetStateAsBbox();
                            mybox bbbox;
                            if (trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits) {
                            // Print to terminal for debugging
                                std::cout << frame_index << "," << trk.first << "," << bbox.block.tl().x << "," << bbox.block.tl().y
                                          << "," << bbox.block.width << "," << bbox.block.height << ",1,-1,-1,-1"
                                          << " Hit Streak = " << trk.second.hit_streak_
                                          << " Coast Cycles = " << trk.second.coast_cycles_ << std::endl;

                                // Export to text file for metrics evaluation
                                //central point!
                                output_file << frame_index << "," << trk.first << "," <<"1,"<<trk.second.category<<","
                                             << bbox.block.tl().x+bbox.block.width*0.5<< "," << bbox.block.tl().y+bbox.block.height*0.5<< "," << bbox.block.width << "," << bbox.block.height<<","
                                             <<trk.second.GetMotionState()(4)<<","<<trk.second.GetMotionState()(5)<<","<<trk.second.GetMotionState()(0)<<","<<trk.second.GetMotionState()(1)<<endl;
                                /*output_file   << trk.first << "," <<"1,"<<trk.second.category<<","
                                             << bbox.block.tl().x << "," << bbox.block.tl().y<< "," << bbox.block.width << "," << bbox.block.height<<","
                                             <<trk.second.GetMotionState()(3)<<","<<trk.second.GetMotionState()(5)<<","<<trk.second.GetMotionState()(0)<<","<<trk.second.GetMotionState()(1);*/


                                //从左至右: x,y,w,h,class,id,ax,ay,vx,vy,frame
                                bbbox.init(bbox.block.tl().x+bbox.block.width*0.5,bbox.block.tl().y+bbox.block.height*0.5,bbox.block.width,bbox.block.height,trk.second.category,trk.first,trk.second.GetMotionState()(4),trk.second.GetMotionState()(5),trk.second.GetMotionState()(0),trk.second.GetMotionState()(1),frame_index);
                                bbox_per_frame.push_back(bbbox);



                                double v = sqrt(trk.second.GetMotionState()(4)*trk.second.GetMotionState()(4) + trk.second.GetMotionState()(5)*trk.second.GetMotionState()(5));
                                double a = sqrt(trk.second.GetMotionState()(0)*trk.second.GetMotionState()(0) + trk.second.GetMotionState()(1)*trk.second.GetMotionState()(1));
                                double v_angle = atan2(trk.second.GetMotionState()(5), trk.second.GetMotionState()(4));
                                double a_angle = atan2(trk.second.GetMotionState()(1), trk.second.GetMotionState()(0));
                                foutput_v<<frame_index<<","<<trk.first<<","<<v<<","<<a<<","<<v_angle<<","<<a_angle<<endl;

                            }
                        }
                        //output_file<<endl;


                        bool flag_frame_empty=true;

                        if(!bbox_per_frame.empty()){
                            bbox1.push_back(bbox_per_frame);
                            bbox_per_frame.clear();
                            flag_frame_empty=false;//this frame isn't empty!
                        }
                       //11帧以后再开始判断
                       if(frame_index>100){
                           if(bbox1.size()>=2&&!flag_frame_empty){
//                               if(bbox1[bbox1.size()-2].at(0).frame==(frame_index-1)){
                        miss_boxes=RXY_findmissingbox(bbox1[bbox1.size()-2],bbox1[bbox1.size()-1]);
  }
//}
                        //(1)从所有box中找高加速度,高速度的对象
                        //(2)进行静止检测
                        //-->nomiss_to_accidentboxes
                        RXY_highacceleration(bbox1[bbox1.size()-1],high_accelerationboxes,motionparasboxes);
                        RXY_nomissstay(bbox1[bbox1.size()-1],high_accelerationboxes,nomiss_to_accidentboxes);

                        //从疑似对象like_to_accidentboxes中找出真正碰撞的对象
                        RXY_morecheck(bbox1[bbox1.size()-1],like_accidentboxes,miss_to_accidentboxes);//找出miss_to_accidnetboxes
                        RXY_Vfix_faccident(miss_to_accidentboxes);//速度消畸变
                        RXY_Vfilter_faccident(miss_to_accidentboxes,vfilter_fmiss,vfilter_for_stay);//根据速度分类:后续做 速度滤波检测 还是 静止检测
                        RXY_neighcheck_accident(bbox1[bbox1.size()-12],vfilter_fmiss,fmiss_to_accidentboxes);//x-x向的滤除
                        RXY_crashonestay(bbox1[bbox1.size()-1],vfilter_for_stay,stay_to_accidentboxes);//crashone静止检测
                        RXY_missstay(bbox1[bbox1.size()-1],vfilter_for_stay,stay_to_accidentboxes);//miss静止检测




                        //判断有无ID消失
                        if(miss_boxes.empty()){
                            flag_ID_missing=false;//没有ID消失
                        }
                        else{
                            flag_ID_missing=true;//有ID消失
                        }

                        //判断每一个消失ID是否为驶离图片或驶远
                        if(flag_ID_missing){
                            //                std::vector<missingbox>::iterator it_miss_boxes;
                            for(int in=0;in<miss_boxes.size();in++){
                                //判断是否是变小或在边缘处消失
                                if(miss_boxes[in].missing_area<=miss_boxes[in].missbox_areathod(miss_boxes[in].missing_type))
                                {   miss_boxes[in].flag_runaway=true;}//变小
                                else if((miss_boxes[in].x<edge_left&&miss_boxes[in].vx<0)||(miss_boxes[in].x>edge_right&&miss_boxes[in].vx>0)||(miss_boxes[in].y<edge_top&&miss_boxes[in].vy<0)||(miss_boxes[in].y>edge_below&&miss_boxes[in].vy>0))
                                {   miss_boxes[in].flag_runaway=true;}//在边缘消失，且其远离图片行驶
                                else
                                {   miss_boxes[in].flag_runaway=false;}
                                //再判断是碰撞还是遮挡
                                if(!(miss_boxes[in].flag_runaway)){
                                    //找出范围r内的相邻物体
                                    cout<<"missid:" <<miss_boxes[in].missing_ID<<endl;
                                    cout<<"bbox1:"<<bbox1[bbox1.size()-2].size()<<endl;
                                    for(int ni=0;ni<bbox1[bbox1.size()-2].size();ni++){
                                        cout<<bbox1[bbox1.size()-2].at(ni).ID_number<<",";
                                    }
                                    neighbourboxes=RXY_findneighbour(miss_boxes[in],bbox1[bbox1.size()-2]);
                                    std::cout<<"neighbor"<<endl;
                                    cout<<neighbourboxes.size()<<endl;
                                    if(!neighbourboxes.empty())//检查neighbor是否为空!
                                    {
                                        //画出当量线段
                                        RXY_getline_forneighbour(neighbourboxes);
                                        RXY_getline_formissbox(miss_boxes[in]);
                                        //计算最近距离
                                        mindistance=RXY_distmin_neighbour(miss_boxes[in],neighbourboxes);
                                        if(mindistance<=crash_distance){
                                            //疑似发生事故
                                            miss_boxes[in].flag_accident=true;
                                            like_accidentboxes.push_back(miss_boxes[in]);//放入疑似事故对象中
                                        }
                                    }
                                }
                            }
                        }


                        //输出文档
//                             std::vector<int>::iterator it_id_check;
//                             std::cout<<"***nomissing accidentboxes***"<<std::endl;
//                               for(auto &nomtacci : nomiss_to_accidentboxes){
//                                   std::cout<<nomtacci.accident_frame<<","<<nomtacci.ID_number<<","<<nomtacci.boxings.x<<","<<nomtacci.boxings.y<<std::endl;
//                                   output_file<<nomtacci.accident_frame<<","<<nomtacci.ID_number<<","<<nomtacci.boxings.x<<","<<nomtacci.boxings.y<<std::endl;
//                                   for(it_id_check=id_check.begin();it_id_check<id_check.end();++it_id_check){
//                                       if((*it_id_check)==nomtacci.ID_number){nomtacci.flag_cout=true;break;}
//                                   }
//                                   if(!nomtacci.flag_cout){id_check.push_back(nomtacci.ID_number);nomissaccident_count++;}
//                               }

                  //      std::cout<<miss_to_accidentboxes.size()<<endl;

                        for(int i=0;i< miss_to_accidentboxes.size();i++){
                            if(!miss_to_accidentboxes[i].flag_output){
                                std::cout<<"***missing accidentboxes***"<<std::endl;
                                std::cout<<miss_to_accidentboxes[i].missing_frame<<","<<miss_to_accidentboxes[i].missing_ID<<","<<miss_to_accidentboxes[i].missing_type<<","<<miss_to_accidentboxes[i].x<<","<<miss_to_accidentboxes[i].y<<","<<miss_to_accidentboxes[i].crashone.ID_number <<"," <<miss_to_accidentboxes[i].vsum_filter<<","<<miss_to_accidentboxes[i].crashone.vsum_filter<<std::endl;
                                //           output_file<<miss_to_accidentboxes[i].missing_frame<<","<<miss_to_accidentboxes[i].missing_ID<<","<<miss_to_accidentboxes[i].missing_type<<","<<miss_to_accidentboxes[i].x<<","<<miss_to_accidentboxes[i].y<<std::endl;
                                miss_to_accidentboxes[i].flag_output=true;
                                missaccident_count++;
                                std::cout<<"****crashone boxes****"<<std::endl;
                                std::cout<<miss_to_accidentboxes[i].crashone.ID_number<<","<<miss_to_accidentboxes[i].crashone.typenumber<<","<<miss_to_accidentboxes[i].crashone.boxings.x<<","<<miss_to_accidentboxes[i].crashone.boxings.y<<std::endl;
                            }
                        }

                        for(int ii=0;ii<vfilter_fmiss.size();ii++){
                            if(!vfilter_fmiss[ii].flag_vout){
                                std::cout<<"***vfilter_fmiss****"<<std::endl;
                                //输出格式:   frame,id,class,x,y,crashone_id,crashone_class,vsum_filter,crashone_vsumfilter
                                std::cout<<vfilter_fmiss[ii].missing_frame<<","<<vfilter_fmiss[ii].missing_ID<<","<<vfilter_fmiss[ii].missing_type<<","<<vfilter_fmiss[ii].x<<","<<vfilter_fmiss[ii].y<<","
                                        <<vfilter_fmiss[ii].crashone.ID_number<<","<<vfilter_fmiss[ii].crashone.typenumber<<","<<vfilter_fmiss[ii].vsum_filter<<","<<vfilter_fmiss[ii].crashone.vsum_filter<<"  "<<vfilter_fmiss[ii].flag_merge_acci<<"," <<vfilter_fmiss[ii].flag_accident<<std::endl;
                                output_file<<vfilter_fmiss[ii].missing_frame<<","<<vfilter_fmiss[ii].missing_ID<<","<<vfilter_fmiss[ii].missing_type<<","<<vfilter_fmiss[ii].x<<","<<vfilter_fmiss[ii].y<<","
                                          <<vfilter_fmiss[ii].crashone.ID_number<<","<<vfilter_fmiss[ii].crashone.typenumber<<","<<vfilter_fmiss[ii].vsum_filter<<","<<vfilter_fmiss[ii].crashone.vsum_filter<<std::endl;
                                vfilter_fmiss[ii].flag_vout=true;
                                vfilterfimss_count++;
                                QString nowtime=QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss ddd");
                                qDebug()<<nowtime;
                                QString accidentype;
                                if(vfilter_fmiss[ii].missing_type==1&&vfilter_fmiss[ii].crashone.typenumber==1)
                                {
                                    accidentype="人人事故";
                                    if(vfilter_fmiss[ii].missing_type==1&&vfilter_fmiss[ii].crashone.typenumber!=1)
                                    {
                                        accidentype="人车事故";
                                        if(vfilter_fmiss[ii].missing_type!=1&&vfilter_fmiss[ii].crashone.typenumber==1)
                                        {
                                            accidentype="车人事故";
                                        }
                                        else {
                                            accidentype="车车事故";
                                        }
                                    }
                                }
                                QSqlQuery query;
                                // 添加信息
                                query.prepare("insert into traffic (currentime, cameranum, filename, frame, type, participant1, speed1, participant2,speed2) values (:currentime,:cameranum,:filename, :frame, :type, :participant1, :speed1, :participant2,:speed2)");
                                // 传递变量
                                QString currentimeValue=nowtime;
                                //QString filenameValue=QString::fromStdString(str);
                                int frameValue=vfilter_fmiss[ii].missing_frame;
                                QString typeValue=accidentype;
                               int participant1Value=vfilter_fmiss[ii].missing_ID;
                               int speed1Value=vfilter_fmiss[ii].vsum_filter;
                               int participant2Value=vfilter_fmiss[ii].crashone.ID_number;
                                int speed2Value=vfilter_fmiss[ii].crashone.vsum_filter;
                                // 添加信息
                                query.bindValue(":currentime", currentimeValue);
                                //query.bindValue(":filename", filenameValue);
                                query.bindValue(":frame", frameValue);
                                query.bindValue(":type", typeValue);
                                query.bindValue(":participant1", participant1Value);
                                query.bindValue(":speed1", speed1Value);
                                query.bindValue(":participant2", participant2Value);
                                query.bindValue(":speed2", speed2Value);
                                query.exec();

                            }
                        }


                        for(int ic=0;ic<stay_to_accidentboxes.size();ic++){
                            if(!stay_to_accidentboxes[ic].flag_sout){
                                std::cout<<"***stay_to_accident***************************"<<std::endl;
  //                                std::cout<<stay_to_accidentboxes[ic].missing_frame<<","<<stay_to_accidentboxes[ic].missing_ID<<","<<stay_to_accidentboxes[ic].crashone.ID_number<<std::endl;
                                //               output_file_1<<stay_to_accidentboxes[ic].missing_frame<<","<<stay_to_accidentboxes[ic].missing_ID<<","<<stay_to_accidentboxes[ic].crashone.ID_number<<std::endl;
                                std::cout<<stay_to_accidentboxes[ic].missing_frame<<","<<stay_to_accidentboxes[ic].missing_ID<<","<<stay_to_accidentboxes[ic].crashone.ID_number<<stay_to_accidentboxes[ic].missing_type<<","
                                <<stay_to_accidentboxes[ic].crashone.typenumber<<","<<stay_to_accidentboxes[ic].vsum_filter<<","<<stay_to_accidentboxes[ic].crashone.vsum_filter;
                                stay_to_accidentboxes[ic].flag_sout=true;
                                stayaccident_count++;
                                QString nowtime1=QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss ddd");
                                qDebug()<<nowtime1;
                                QString accidentype1;
                                if(stay_to_accidentboxes[ic].missing_type==1&&stay_to_accidentboxes[ic].crashone.typenumber==1)
                                {
                                    accidentype1="人人事故";
                                    if(stay_to_accidentboxes[ic].missing_type==1&&stay_to_accidentboxes[ic].crashone.typenumber!=1)
                                    {
                                        accidentype1="人车事故";
                                        if(stay_to_accidentboxes[ic].missing_type!=1&&stay_to_accidentboxes[ic].crashone.typenumber==1)
                                        {
                                            accidentype1="车人事故";
                                        }
                                        else {
                                            accidentype1="车车事故";
                                        }
                                    }
                                }
                                QSqlQuery query;
                                // 添加信息
                                query.prepare("insert into traffic (currentime, cameranum, filename, frame, type, participant1, speed1, participant2,speed2) values (:currentime,:cameranum,:filename, :frame, :type, :participant1, :speed1, :participant2,:speed2)");
                                // 传递变量
                                QString currentimeValue=nowtime1;
                                //QString filenameValue=QString::fromStdString(str);
                                int frameValue=stay_to_accidentboxes[ic].missing_frame;
                                QString typeValue=accidentype1;
                               int participant1Value=stay_to_accidentboxes[ic].missing_ID;
                               int speed1Value=stay_to_accidentboxes[ic].vsum_filter;
                               int participant2Value=stay_to_accidentboxes[ic].crashone.ID_number;
                                int speed2Value=stay_to_accidentboxes[ic].crashone.vsum_filter;
                                // 添加信息
                                query.bindValue(":currentime", currentimeValue);
                                //query.bindValue(":filename", filenameValue);
                                query.bindValue(":frame", frameValue);
                                query.bindValue(":type", typeValue);
                                query.bindValue(":participant1", participant1Value);
                                query.bindValue(":speed1", speed1Value);
                                query.bindValue(":participant2", participant2Value);
                                query.bindValue(":speed2", speed2Value);
                                query.exec();
                            }
                        }

                        for(int ii=0;ii<fmiss_to_accidentboxes.size();ii++){
                            if(!fmiss_to_accidentboxes[ii].flag_foutput){
                                std::cout<<"******************fmiss**************************"<<std::endl;
                                std::cout<<fmiss_to_accidentboxes[ii].missing_frame<<","<<fmiss_to_accidentboxes[ii].missing_ID<<","<<fmiss_to_accidentboxes[ii].missing_type<<","<<fmiss_to_accidentboxes[ii].x<<","<<fmiss_to_accidentboxes[ii].y<<","
                                        <<fmiss_to_accidentboxes[ii].crashone.ID_number<<","<<fmiss_to_accidentboxes[ii].crashone.typenumber<<","<<fmiss_to_accidentboxes[ii].crashone.dist_neighcheck<<","<<fmiss_to_accidentboxes[ii].flag_merge_stay1<<"," <<fmiss_to_accidentboxes[ii].crashone.boxings.width <<std::endl;
                //                           output_file<<fmiss_to_accidentboxes[ii].missing_frame<<","<<fmiss_to_accidentboxes[ii].missing_ID<<","<<fmiss_to_accidentboxes[ii].missing_type<<","<<fmiss_to_accidentboxes[ii].x<<","<<fmiss_to_accidentboxes[ii].y<<","
                //                                     <<fmiss_to_accidentboxes[ii].crashone.ID_number<<","<<fmiss_to_accidentboxes[ii].crashone.typenumber<<std::endl;
                                fmiss_to_accidentboxes[ii].flag_foutput=true;
                                fmissaccident_count++;

                            }
                        }


                        //统计所有的疑似对象个数
                        for(auto &likeab : like_accidentboxes ){
                            if(!like_accidentboxes.empty()){
                                if(!likeab.flag_cout){
                                    std::cout<<"******like_accidentboxes***"<<std::endl;
                                    std::cout<<frame_index-1<<","<<likeab.missing_frame<<","<<likeab.missing_ID<<","<<likeab.missing_type<<std::endl;
                                    likeab.flag_cout=true;
                                    like_count++;
                                }
                            }
                        }

                        miss_boxes.clear();//不储存每一帧消失的对象
                        neighbourboxes.clear();


                       }// end of if(frame_index>11)

                        if (enable_display_flag) {
                                        if (frame.empty()) {
                                            std::cerr << "Could not open or find the image!!!" << std::endl;
                                            //return -1;
                                        }

                                        for (const auto &det : one_frame_dec) {
                                            // Draw detected bounding boxes in red
                                            cv::Rect myRect_to_cv(det.block.x,det.block.y,det.block.width,det.block.height);
                                            std::string display_str=std::to_string(frame_index);
                                            cv::rectangle(frame, myRect_to_cv, cv::Scalar(0, 0, 255), 3);
                                        }

                                        for (auto &trk : tracks) {//draw box after matching

                                            if ((trk.second.hit_streak_ >= kMinHits || frame_index < kMinHits)) {
                                                const auto &bbox = trk.second.GetStateAsBbox();
                                                cv::Rect myRect_to_cv(bbox.block.x,bbox.block.y,bbox.block.width,bbox.block.height);
                                                std::string display_str=std::to_string(frame_index);
                                                display_str+=" ";
                                               // display_str+=std::to_string(trk.second.category);
                                              //  display_str+=" ";
                                                display_str+=std::to_string(trk.first);
                                                cv::putText(img_tracking, display_str, cv::Point(bbox.block.tl().x, bbox.block.tl().y - 10),cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(255, 255, 255), 1);
                                                cv::rectangle(img_tracking, myRect_to_cv, colors[trk.first % num_of_colors], 3);
                                                trk.second.drawstateline(img_tracking,colors[trk.first % num_of_colors]);
                                            }

                                        }

                                       // Show our image inside it
                                        cv::namedWindow("Detecing", CV_WINDOW_NORMAL);
                                        cv::namedWindow("Tracking", CV_WINDOW_NORMAL);

                                        p->video_opencv(frame);


                                        cv::imshow("Detecing", frame);
                                        writer_dec<<frame;

                                        cv::imshow("Tracking", img_tracking);
                                        writer_match<<img_tracking;
                                        //p->video_opencv(img_tracking);

                                        // Exit if ESC pressed
                                        int c=cv::waitKey(1);
                                              if((char)c==27)
                                                  break;
                                              else if(c>=0)
                                                 cv:: waitKey(1);
                                    } // end of enable_display_flag



            free(srcImg);
            free(resizeImg);
            frame_index++;

        }//while stop




















//将vfilter和stay的结果合并输出
              if(!vfilterfimss_count){
                  total_vfilter_stay.insert(total_vfilter_stay.begin(),stay_to_accidentboxes.begin(),stay_to_accidentboxes.end());
              }
              else if (!stayaccident_count) {
                  total_vfilter_stay.insert(total_vfilter_stay.begin(), vfilter_fmiss.begin(),vfilter_fmiss.end());
              }
              else {
                  if((vfilterfimss_count+stayaccident_count)<=6){
                     total_vfilter_stay.insert(total_vfilter_stay.begin(), vfilter_fmiss.begin(),vfilter_fmiss.end());
                     total_vfilter_stay.insert(total_vfilter_stay.end(),stay_to_accidentboxes.begin(),stay_to_accidentboxes.end());
                  }
                  else{
                      total_vfilter_stay.insert(total_vfilter_stay.begin(), vfilter_fmiss.begin(),vfilter_fmiss.end());
                  }
              }

//将nomiss和total的结果合并输出
              if(total_vfilter_stay.empty()){
                  for(int ww=0;ww<nomiss_to_accidentboxes.size();ww++){
                      if(!nomiss_to_accidentboxes[ww].flag_ooutput){
                          //输出格式:   frame,id,class,x,y,crashone_id,crashone_class,vsum_filter,crashone_vsumfilter
                          output_file<<nomiss_to_accidentboxes[ww].frame+1<<","<<nomiss_to_accidentboxes[ww].ID_number<<","<<nomiss_to_accidentboxes[ww].typenumber<<","<<nomiss_to_accidentboxes[ww].boxings.x<<","<<nomiss_to_accidentboxes[ww].boxings.y<<std::endl;
                          //                              <<nomiss_to_accidentboxes[ww].crashone1.typenumber<<","<<vfilter_fmiss[ii].crashone.typenumber<<","<<vfilter_fmiss[ii].vsum_filter<<","<<vfilter_fmiss[ii].crashone.vsum_filter<<std::endl;
                          nomiss_to_accidentboxes[ww].flag_ooutput=true;
                      }
                  }
              }
              else if(nomiss_to_accidentboxes.empty()){
                  for(int ee=0;ee<total_vfilter_stay.size();ee++){
                      if(!total_vfilter_stay[ee].flag_ooutput){
                          output_file<<total_vfilter_stay[ee].missing_frame<<","<<total_vfilter_stay[ee].missing_ID<<","<<total_vfilter_stay[ee].missing_type<<","<<total_vfilter_stay[ee].x<<","<<total_vfilter_stay[ee].y<<","
                                    <<total_vfilter_stay[ee].crashone.ID_number<<","<<total_vfilter_stay[ee].crashone.typenumber<<","<<total_vfilter_stay[ee].vsum_filter<<","<<total_vfilter_stay[ee].crashone.vsum_filter<<std::endl;
                          total_vfilter_stay[ee].flag_ooutput=true;
                          QString nowtime2=QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss ddd");
                          qDebug()<<nowtime2;
                          QString accidentype2;
                          if(total_vfilter_stay[ee].missing_type==1&&total_vfilter_stay[ee].crashone.typenumber==1)
                          {
                              accidentype2="人人事故";
                              if(total_vfilter_stay[ee].missing_type==1&&total_vfilter_stay[ee].crashone.typenumber!=1)
                              {
                                  accidentype2="人车事故";
                                  if(total_vfilter_stay[ee].missing_type!=1&&total_vfilter_stay[ee].crashone.typenumber==1)
                                  {
                                      accidentype2="车人事故";
                                  }
                                  else {
                                      accidentype2="车车事故";
                                  }
                              }
                          }
                          QSqlQuery query;
                          // 添加信息
                          query.prepare("insert into traffic (currentime, cameranum, filename, frame, type, participant1, speed1, participant2,speed2) values (:currentime,:cameranum,:filename, :frame, :type, :participant1, :speed1, :participant2,:speed2)");
                          QString currentimeValue=nowtime2;
                          // 传递变量
                          //QString filenameValue=QString::fromStdString(str);
                          int frameValue=total_vfilter_stay[ee].missing_frame;
                          QString typeValue=accidentype2;
                         int participant1Value=total_vfilter_stay[ee].missing_ID;
                         int speed1Value=total_vfilter_stay[ee].vsum_filter;
                         int participant2Value=total_vfilter_stay[ee].crashone.ID_number;
                          int speed2Value=total_vfilter_stay[ee].crashone.vsum_filter;
                          // 添加信息
                          query.bindValue(":currentime", currentimeValue);
                          //query.bindValue(":filename", filenameValue);
                          query.bindValue(":frame", frameValue);
                          query.bindValue(":type", typeValue);
                          query.bindValue(":participant1", participant1Value);
                          query.bindValue(":speed1", speed1Value);
                          query.bindValue(":participant2", participant2Value);
                          query.bindValue(":speed2", speed2Value);
                          query.exec();
                      }
                  }
              }
              else{
                  if(total_vfilter_stay.size()>6){
                      for(int ww=0;ww<nomiss_to_accidentboxes.size();ww++){
                          if(!nomiss_to_accidentboxes[ww].flag_ooutput){
                              //输出格式:   frame,id,class,x,y,crashone_id,crashone_class,vsum_filter,crashone_vsumfilter
                              output_file<<nomiss_to_accidentboxes[ww].frame+1<<","<<nomiss_to_accidentboxes[ww].ID_number<<","<<nomiss_to_accidentboxes[ww].typenumber<<","<<nomiss_to_accidentboxes[ww].boxings.x<<","<<nomiss_to_accidentboxes[ww].boxings.y<<std::endl;
                              //                              <<nomiss_to_accidentboxes[ww].crashone1.typenumber<<","<<vfilter_fmiss[ii].crashone.typenumber<<","<<vfilter_fmiss[ii].vsum_filter<<","<<vfilter_fmiss[ii].crashone.vsum_filter<<std::endl;
                              nomiss_to_accidentboxes[ww].flag_ooutput=true;
                          }
                      }
                  }
                  else{
                      if(total_vfilter_stay.size()+nomiss_to_accidentboxes.size()<=6){
                          for(int ww=0;ww<nomiss_to_accidentboxes.size();ww++){
                              if(!nomiss_to_accidentboxes[ww].flag_ooutput){
                                  //输出格式:   frame,id,class,x,y,crashone_id,crashone_class,vsum_filter,crashone_vsumfilter
                                  output_file<<nomiss_to_accidentboxes[ww].frame+1<<","<<nomiss_to_accidentboxes[ww].ID_number<<","<<nomiss_to_accidentboxes[ww].typenumber<<","<<nomiss_to_accidentboxes[ww].boxings.x<<","<<nomiss_to_accidentboxes[ww].boxings.y<<std::endl;
                                  //                              <<nomiss_to_accidentboxes[ww].crashone1.typenumber<<","<<vfilter_fmiss[ii].crashone.typenumber<<","<<vfilter_fmiss[ii].vsum_filter<<","<<vfilter_fmiss[ii].crashone.vsum_filter<<std::endl;
                                  nomiss_to_accidentboxes[ww].flag_ooutput=true;
                              }
                          }
                          for(int ee=0;ee<total_vfilter_stay.size();ee++){
                              if(!total_vfilter_stay[ee].flag_ooutput){
                                  output_file<<total_vfilter_stay[ee].missing_frame<<","<<total_vfilter_stay[ee].missing_ID<<","<<total_vfilter_stay[ee].missing_type<<","<<total_vfilter_stay[ee].x<<","<<total_vfilter_stay[ee].y<<","
                                            <<total_vfilter_stay[ee].crashone.ID_number<<","<<total_vfilter_stay[ee].crashone.typenumber<<","<<total_vfilter_stay[ee].vsum_filter<<","<<total_vfilter_stay[ee].crashone.vsum_filter<<std::endl;
                                  total_vfilter_stay[ee].flag_ooutput=true;
                              }
                          }
                      }
                      else{
                          for(int ee=0;ee<total_vfilter_stay.size();ee++){
                              if(!total_vfilter_stay[ee].flag_ooutput){
                                  output_file<<total_vfilter_stay[ee].missing_frame<<","<<total_vfilter_stay[ee].missing_ID<<","<<total_vfilter_stay[ee].missing_type<<","<<total_vfilter_stay[ee].x<<","<<total_vfilter_stay[ee].y<<","
                                            <<total_vfilter_stay[ee].crashone.ID_number<<","<<total_vfilter_stay[ee].crashone.typenumber<<","<<total_vfilter_stay[ee].vsum_filter<<","<<total_vfilter_stay[ee].crashone.vsum_filter<<std::endl;
                                  total_vfilter_stay[ee].flag_ooutput=true;
                              }
                          }
                      }
                  }
              }


              std::cout<<"******事故对象总计******"<<std::endl;

              std::cout<<"missingaccident_count:"<<missaccident_count<<std::endl;
              std::cout<<"total accidentID_count:"<<missaccident_count+nomissaccident_count<<std::endl;
              std::cout<<"like_count:"<<like_count<<std::endl;
              std::cout<<"vfilter_count:"<<vfilterfimss_count<<std::endl;
              std::cout<<"addvfilter_count:"<<addvfilterfmiss_count<<std::endl;
              std::cout<<"fmissaccident_count:"<<fmiss_to_accidentboxes.size()<<std::endl;
              std::cout<<"stayaccident_count:"<<stayaccident_count<<std::endl;
              std::cout<<"total vfilter&stay count:"<<total_vfilter_stay.size()<<std::endl;
              std::cout<<"highaccelerationboxes count:"<<high_accelerationboxes.size()<<std::endl;
              std::cout<<"nomissingaccident_count:"<<nomiss_to_accidentboxes.size()<<std::endl;


              std::cout<<"****higha*****"<<std::endl;
              for(int qq=0;qq<high_accelerationboxes.size();qq++){
                  if(!high_accelerationboxes[qq].flag_loutput){
                      std::cout<<high_accelerationboxes[qq].frame+1<<","<<high_accelerationboxes[qq].ID_number<<","<<high_accelerationboxes[qq].a_sum<<","<<high_accelerationboxes[qq].v_sum<<std::endl;
                      high_accelerationboxes[qq].flag_loutput=true;
                  }
              }

              std::cout<<"***nomiss**************************"<<std::endl;
              for(int ii=0;ii<nomiss_to_accidentboxes.size();ii++){
                  if(!nomiss_to_accidentboxes[ii].flag_noutput){
                      std::cout<<nomiss_to_accidentboxes[ii].frame+1<<","<<nomiss_to_accidentboxes[ii].ID_number<<","<<nomiss_to_accidentboxes[ii].a_sum<<","<<nomiss_to_accidentboxes[ii].v_sum<<std::endl;
                      nomiss_to_accidentboxes[ii].flag_noutput=true;

                  }
              }

              std::cout<<"***total vfilter&stay***"<<std::endl;
              for(int ie=0;ie<total_vfilter_stay.size();ie++){
                  if(!total_vfilter_stay[ie].flag_tout){
                      std::cout<<total_vfilter_stay[ie].missing_frame<<","<<total_vfilter_stay[ie].missing_ID<<","<<total_vfilter_stay[ie].crashone.ID_number<<std::endl;
                      //               output_file_1<<stay_to_accidentboxes[ic].missing_frame<<","<<stay_to_accidentboxes[ic].missing_ID<<","<<stay_to_accidentboxes[ic].crashone.ID_number<<std::endl;
                      total_vfilter_stay[ie].flag_tout=true;
                      total_vs_count++;
                  }
              }










         //std::cout<<"while end";
        std::vector<std::string> judge_txt;
        judge_txt.push_back("1,2,3,4,5,6,7");

        string aa="请点击右边 显示内容 按钮显示事故诊断结果";
        p->printmsg("视频已处理完成，在视频原目录下生成"+output_path+"  "+folder+name+"match.mp4"+"\n"+aa);


        output_file.close();

        free_network(net);
        //std::cout<<"dec_match"<<output_path;
        return output_path;
}
